{"0": {
    "doc": "Compilation",
    "title": "Compilation",
    "content": "Compilation . The include file DeLaFitsDefine contains the conditional compilation directives for DeLaFits. Most of them are defined automatically depending on the toolchain and platform. Others have default values, but you can change them. Memory manager . DeLaFits uses an intermediate buffer for read and write operations. You can determine how memory for this buffer will be allocated and freed. | {$DELAFITS_MEMORY_SHARED} − all TFitsContainer instances use a shared buffer. This directive enhances the performance of read and write operations while also reducing memory fragmentation. However, in this case, read and write operations in multithreaded applications must be synchronized. | {$DELAFITS_MEMORY_OBJECT} − each TFitsContainer instance operates with its own buffer. Increases memory usage and fragmentation proportional to the number of TFitsContainer instances. Work with TFitsContainer instances in different threads (not tested). | {$DELAFITS_MEMORY_LOCAL} − each TFitsContainer instance creates a temporary buffer as needed and frees it immediately after use. Memory is used sparingly, but fragmentation increases, and read and write performance may decrease. Work with TFitsContainer instances in different threads (not tested). | . {$DELAFITS_MEMORY_SHARED} directive set by default. NaN math . By default, the {$DELAFITS_MATH_NAN} directive is defined, which allows working with NaN values. This slows down read and write operations. If your TFitsContainer instances do not contain NaN values, you can disable this behavior using the {$DELAFITS_MATH_NAN_OFF} directive. Pseudorandom number generator . To customize a pseudorandom number generator, define the {$DELAFITS_CUSTOM_RANDOM} directive and use the DeLaFitsMath.SetCustomRandom procedure. Useful for unit testing. By default, the directive is not defined; DeLaFits uses the generator from the standard library. Round render . {$DELAFITS_ROUND_RENDER} directive enables the rounding of pixel value when rendering an IMAGE extension. Useful for unit testing. By default, the directive is not defined. ",
    "url": "https://felleroff.github.io/delafits/pages/compilation/",
    "relUrl": "/pages/compilation/"
  },"1": {
    "doc": "Error codes 1000-1999",
    "title": "Error codes 1000-1999",
    "content": "Error codes 1000-1999 . DeLaFitsCommon unit. Types, constants, keyword dictionary and simple functions. 1000, ERROR_FITS . The constant is not used explicitly. It is the starting value for other library error codes . 1001, ERROR_NULL . Unexpected null value . 1002, ERROR_UNKNOWN . Unknown error . ",
    "url": "https://felleroff.github.io/delafits/pages/errors/delafitscommon/",
    "relUrl": "/pages/errors/delafitscommon/"
  },"2": {
    "doc": "Error codes 2000-2999",
    "title": "Error codes 2000-2999",
    "content": "Error codes 2000-2999 . DeLaFitsMath unit. Mathematics functions. 2000, ERROR_MATH . 2100, ERROR_MATH_NAN_PICTURE . NaN cannot be set as a replacement for NaN for the bitmap build function from IMAGE data . 2200, ERROR_MATH_MATRIX_SHIFT . To create an affine transformation matrix, the shift is not allowed to have values from the set {NaN, ±INF} . 2201, ERROR_MATH_MATRIX_SCALE . To create an affine transformation matrix, the scale factor is not allowed to have values from the set {NaN, ±INF, 0.0} . 2202, ERROR_MATH_MATRIX_ROTATE . To create an affine transformation matrix, the rotation angle is not allowed to have values from the set {NaN, ±INF} . 2203, ERROR_MATH_MATRIX_SHEARX . To create an affine transformation matrix, the shear angle along the X-axis value must not be out of range (-90°.0 .. +90°.0) . 2204, ERROR_MATH_MATRIX_SHEARY . To create an affine transformation matrix, the shear angle along the Y-axis value must not be out of range (-90°.0 .. +90°.0) . 2205, ERROR_MATH_MATRIX_ZTERM . Invalid value of the Z-term (third column) of the affine transformation matrix. The Z-term must always be equal to [0.0, 0.0, 1.0] . &nbsp;&nbsp;&nbsp; M11M12M13 M21M22M23 M31M32M33 &nbsp;&nbsp;&nbsp; &nbsp;≡&nbsp; &nbsp;&nbsp;&nbsp; M11M12M13 M21M22M23 0.00.01.0 &nbsp;&nbsp;&nbsp; . 2206, ERROR_MATH_MATRIX_DET . Invalid value of the determinant of the affine transformation matrix. The determinant must always be non-zero . &nbsp;det&nbsp; &nbsp;&nbsp;&nbsp; M11M12M13 M21M22M23 M31M32M33 &nbsp;&nbsp;&nbsp; &nbsp;≠&nbsp; &nbsp;0.0&nbsp; ",
    "url": "https://felleroff.github.io/delafits/pages/errors/delafitsmath/",
    "relUrl": "/pages/errors/delafitsmath/"
  },"3": {
    "doc": "Error codes 4000-4999",
    "title": "Error codes 4000-4999",
    "content": "Error codes 4000-4999 . DeLaFitsProp unit. Typed properties of the header keyword records. The TFitsProp class is convenient for working with keyword records. Other library classes use this type to parse the header, create a new HDU specification, and cache some keyword record values in the header. 4000, ERROR_PROP . 4100, ERROR_PROPLIST_INDEX . Invalid index value for access to object list item type “keyword - typed value” . 4101, ERROR_PROPLIST_DUPLICATE . Error adding object to a list of type “keyword - typed value”. Lists of this type do not allow duplicates . ",
    "url": "https://felleroff.github.io/delafits/pages/errors/delafitsprop/",
    "relUrl": "/pages/errors/delafitsprop/"
  },"4": {
    "doc": "Error codes 3000-3999",
    "title": "Error codes 3000-3999",
    "content": "Error codes 3000-3999 . DeLaFitsString unit. String functions for formatting and converting the header keyword records. 3000, ERROR_STRING . 3100, ERROR_STRING_LINE_LENGTH . The string is less than 80 characters long, which is not enough to convert it to the header keyword record (keyword; value; note) . 3200, ERROR_STRING_BOOLEAN . Invalid string value for conversion to Boolean type, valid values are {“T”, ”F”} . 3210, ERROR_STRING_BITPIX . Invalid string value for conversion to TBitPix type, valid values are {“-64”, ”-32”, ”8”, ”16”, ”32”, ”64”} . 3220, ERROR_STRING_INT64 . Invalid string value for conversion to Int64 type. The range for the Int64 type is from -263 through 263-1 . 3230, ERROR_STRING_INTEGER . Invalid string value for conversion to Integer type . 3240, ERROR_STRING_FLOAT . Invalid string value for conversion to Float type . 3250, ERROR_STRING_DATETIME . Invalid string value for conversion to TDateTime type. The string must be in the format “YYYY‑MM‑DDThh:mm:ss[.sss]” . 3251, ERROR_STRING_DATETIME_FRAC_SECOND . Error converting a precise date and time value to a string: invalid atto-seconds value. The range for the atto-second values is from 0 to 1018-1 . 3252, ERROR_STRING_DATETIME_PREC_SECOND . Error converting a precise date and time value to a string: invalid conversion precision value. The range of precision values is from 0 to 18 . 3260, ERROR_STRING_COORDINATE_LENGTH . Invalid string value for conversion to coordinates: invalid number of components. In mixed form, the string must consist of three components separated by some character. For example, the format of the string representation of Right ascension in hour units is “HH:MM:SS[.sss]” . 3261, ERROR_STRING_COORDINATE_VALUE . Invalid string value for conversion to coordinates: invalid component values. The values of the components of a mixed form string have a specific range. For example, the string representation of Right ascension in hour units might be “HH:MM:SS[.sss]”, where “HH” ranges from 0 to 23, while “MM” and “SS” range from 0 to 59 . 3262, ERROR_STRING_RA . Incorrect Right ascension value. The Right ascension value is in the range [0°.0 .. 360°.0) or [0h.0 .. 24h.0) . 3263, ERROR_STRING_DE . Incorrect Declination value. The Declination value is in the range (-90°.0 .. +90°.0) . ",
    "url": "https://felleroff.github.io/delafits/pages/errors/delafitsstring/",
    "relUrl": "/pages/errors/delafitsstring/"
  },"5": {
    "doc": "Design",
    "title": "Design",
    "content": "Design . The entry point to DeLaFits is the TFitsContainer class from the DeLaFitsClasses unit. TFitsContainer parses a TStream instance and stores a reference to it. After successfully parsing the stream, the container contains a list of HDUs, which are instances of the TFitsItem class. Each HDU includes both the header and data sections, which are instances of the TFitsItemHead and TFitsItemData classes. The HDU header consists of keyword records, and to work with them, you need to create instances of the TFitsCard class. HDU extensions are implemented in separate units as inheritors of the TFitsItem, TFitsItemHead, and TFitsItemData classes. Use the Container.ItemClasses[Index] property to set the specific HDU extension type. IMAGE extension . The DeLaFitsImage unit contains the implementation of the IMAGE extension. The TFitsImageData class contains methods for working with the physical values of the extension data section. The DeLaFitsPicture unit inherits the DeLaFitsImage unit classes and works with IMAGE extension data as an array of two-dimensional frames. This approach is convenient because observers often use two-dimensional SIFs to store optical observation results. To read and write the physical values (pixels) of a frame and render it to a bitmap, create an instance of the TFitsFrame class. TABLE extension . The DeLaFitsTable unit contains the implementation of the TABLE extension. The TFitsTableData class contains properties and methods for working with table records and fields, similar to well-known Delphi/Lazarus dataset components. TFitsField instances are created automatically but can be customized. They contain methods for reading and writing the physical values of the fields in the active table record. Exception . The EFitsException class is the base class for all DeLaFits exceptions. Each DeLaFits exception has Topic and Code properties to determine the exact cause of the error. DeLaFits uses unique exception classes to increase the verbosity of error messages. ",
    "url": "https://felleroff.github.io/delafits/pages/design/",
    "relUrl": "/pages/design/"
  },"6": {
    "doc": "Errors",
    "title": "Errors",
    "content": "Errors . DeLaFits Exceptions inherit from the EFitsException class. Each exception object has a Topic and Code that uniquely identify the error. uses ..., DeLaFitsCommon, ...; try ... except on E: EFitsException do case E.Code of ERROR1: ...; ERROR2: ...; ... end; end; . The DeLaFits error message has the prefix “$DELAFITS-TOPIC-CODE”. $DELAFITS-CONTAINER-6702, Class \"TFitsImage\" cannot work with HDU extension \"TABLE\" . Each DeLaFits unit has a unique error code range of up to one thousand values: . | Error codes 1000-1999 / DeLaFitsCommon unit . | Error codes 2000-2999 / DeLaFitsMath unit . | Error codes 3000-3999 / DeLaFitsString unit . | Error codes 4000-4999 / DeLaFitsProp unit . | . See Also . | Design, Exception | . ",
    "url": "https://felleroff.github.io/delafits/pages/errors",
    "relUrl": "/pages/errors"
  },"7": {
    "doc": "Get Started",
    "title": "Get Started",
    "content": "Get Started . Read about the FITS file organization. FITS is an HDU container. Each HDU consists of a header and a data section. The header is a set of keyword records in the form of ASCII “keyword=value/note” cards. The data section is a stream of bytes encoded according to the HDU extension. Add the library’s “source” directory to your project’s search path. Review the examples of working with FITS: . | Example 1. Read and write the HDU header | Example 2. Read and write the HDU data | Example 3. Read and write the IMAGE values | Example 4. Create a new IMAGE frame | Example 5. Render an IMAGE frame | Example 6. Create a new TABLE | Example 7. Read and write the TABLE records | . Example 1. Read and write the HDU header . To work with keyword records in the HDU header, create specialized card objects. Each descendant of the TFitsCard class implements methods for reading and writing the keyword name, as well as its associated value and note. See also the “itemhead” demo. uses ..., DeLaFitsCommon, DeLaFitsClasses, DeLaFitsCard; . Create the FITS container: open and parse the FITS file . LStream := TFileStream.Create('demo-item.fits', fmOpenReadWrite); LContainer := TFitsContainer.Create(LStream); . The FITS container contains a list of HDUs. Get the header of the selected HDU . for LIndex := 0 to LContainer.Count - 1 do LItem := LContainer.Items[LIndex]; LHead := LItem.Head; . Loop through the header cards . if LHead.FirstCard then repeat LKeyword := LHead.CardKeyword; ... until not LHead.NextCard; . Get the Right ascension of the observed object defined by the keyword “RA” . LCard := TFitsRightAscensionCard.Create; if LHead.LocateCard('RA') then begin LCard.Card := LHead.Card; LValue := LCard.ValueAsDouble; end; LCard.Free; . Set the observation date defined by the keyword “DATE-OBS” . LCard := TFitsDateTimeCard.Create; if LHead.LocateCard('DATE-OBS') then begin LCard.Card := LHead.Card; LCard.ValueAsDateTime := Now; LHead.Card := LCard.Card; end else begin LCard.Keyword := 'DATE-OBS'; LCard.ValueAsDateTime := Now; LCard.Note := 'Date of the observation'; LHead.AddCard(LCard.Card); end; LCard.Free; . Free objects . LContainer.Free; LStream.Free; . ⮝ . Example 2. Read and write the HDU data . To work with the raw byte stream of the HDU data, use the properties and methods of the TFitsItemData instance. Important! Content access methods do not convert the byte stream into physical values. See also the “itemdata” demo. uses ..., DeLaFitsCommon, DeLaFitsClasses; . Create the FITS container: open and parse the FITS file . LStream := TFileStream.Create('demo-item.fits', fmOpenReadWrite); LContainer := TFitsContainer.Create(LStream); . The FITS container contains a list of HDUs. Get the data object of the selected HDU . for LIndex := 0 to LContainer.Count - 1 do LItem := LContainer.Items[LIndex]; LData := LItem.Data; . Read the data contents . var LChunk: array of Byte; SetLength(LChunk, LData.InternalSize); LData.ReadChunk({AInternalOffset:} 0, Length(LChunk), {var} LChunk[0]); . Write the data contents . var LChunk: array of Byte; SetLength(LChunk, LData.InternalSize); FillChar(LChunk[0], Length(LChunk), $FF); LData.WriteChunk({AInternalOffset:} 0, Length(LChunk), LChunk[0]); . Free objects . LContainer.Free; LStream.Free; . ⮝ . Example 3. Read and write the IMAGE values . To work with physical values of the IMAGE extension, set the HDU class as TFitsImage and use the properties and methods of its data object. See also the “imagevalues” demo. uses ..., DeLaFitsCommon, DeLaFitsClasses, DeLaFitsImage; . Create the FITS container: open and parse the FITS file . LStream := TFileStream.Create('demo-image.fits', fmOpenReadWrite); LContainer := TFitsContainer.Create(LStream); . Set the HDU class to TFitsImage and get its data object . LIndex := 0; if LContainer.ItemExtensionTypeIs(LIndex, TFitsImage) then begin LContainer.ItemClasses[LIndex] := TFitsImage; LImage := LContainer.Items[LIndex] as TFitsImage; LData := LImage.Data; end; . Get the optimal buffer type and read the physical values of the IMAGE data . case LData.ValueType of // floating-point physical values num80f, num64f, num32f: begin var LBuffer: array of Extended; SetLength(LBuffer, LData.ValueCount); LData.ReadValues({AIndex:} 0, Length(LBuffer), {var} TA80f(LBuffer)); end; // integer physical values num08c, num08u, num16c, num16u, num32c, num32u, num64c: begin var LBuffer: array of Int64; SetLength(LBuffer, LData.ValueCount); LData.ReadValues({AIndex:} 0, Length(LBuffer), {var} TA64c(LBuffer)); end; end; . Write the physical values of the IMAGE data . var LBuffer: array of Integer; SetLength(LBuffer, LData.ValueCount); for LIndex := Low(LBuffer) to High(LBuffer) do LBuffer[LIndex] := ...; LData.WriteValues({AIndex:} 0, Length(LBuffer), TA32c(LBuffer)); . Free objects . LContainer.Free; LStream.Free; . ⮝ . Example 4. Create a new IMAGE frame . An IMAGE extension instance contains a multidimensional array of physical values in its data section. Such an array can be presented as a set of frames, which are two-dimensional arrays with dimensions [NAXIS1⨯NAXIS2]. To create a new frame, add an HDU of type TFitsPicture with the TFitsPictureSpec specification to the FITS container. Then, extract the TFitsFrame object and write the physical values into it. See also the “newframe” demo. uses ..., DeLaFitsCommon, DeLaFitsClasses, DeLaFitsPicture; . Create a new empty file and use it to create the FITS container . LStream := TFileStream.Create('new.fits', fmCreate); LContainer := TFitsContainer.Create(LStream); . Create a specification for a new frame: array [1000⨯1200] of 16-bit unsigned integer values . LSpec := TFitsPictureSpec.CreateNew( {AValueType:} num16u, {AFrameWidth:} 1000, {AFrameHeight:} 1200); . Add a new HDU of type TFitsPicture (IMAGE extension) to the FITS container . LPicture := LContainer.Add(TFitsPicture, LSpec) as TFitsPicture; . Get a handle to the first frame of the HDU . LFrameHandle := LPicture.Data.FrameHandles[0]; . Create a new frame object . LFrame := TFitsFrame.Create(LFrameHandle); . Prepare a 16-bit unsigned integer buffer and write the frame values row by row . var LBuffer: array of Word; SetLength(LBuffer, LFrame.Width); for LY := 0 to LFrame.Height - 1 do begin for LX := Low(LBuffer) to High(LBuffer) LBuffer[LX] := ...; LFrame.WriteValues({AX:} 0, {AY:} LY, Length(LBuffer), TA16u(LBuffer)); end; . Free objects . LFrame.Free; LSpec.Free; LContainer.Free; LStream.Free; . ⮝ . Example 5. Render an IMAGE frame . The IMAGE extension instance contains a multidimensional array of physical values in its data section. Such an array can be presented as a set of frames, which are two-dimensional arrays with dimensions [NAXIS1⨯NAXIS2]. Set the HDU class to TFitsPicture, extract the frame as a TFitsFrame object, and use its properties and methods to create a bitmap of some region. See also the “renderframe” demo. uses ..., DeLaFitsCommon, DeLaFitsClasses, DeLaFitsPicture; . Create the FITS container: open and parse the FITS file . LStream := TFileStream.Create('demo-image.fits', fmOpenRead); LContainer := TFitsContainer.Create(LStream); . Set the HDU class to TFitsPicture . LIndex := 0; if LContainer.ItemExtensionTypeIs(LIndex, TFitsPicture) then begin LContainer.ItemClasses[LIndex] := TFitsPicture; LPicture := LContainer.Items[LIndex] as TFitsPicture; end; . Get a handle to the first frame of the HDU . LFrameHandle := LPicture.Data.FrameHandles[0]; . Create a frame object . LFrame := TFitsFrame.Create(LFrameHandle); . Optional. Set rendering parameters: increase contrast, invert color, and scale the frame scene . LFrame.Tone.Contrast := 1.5; LFrame.Palette.Reverse := True; LFrame.Geometry.Scale({ASX:} 2.0, {ASY:} 2.0, {APoint:} xy00); . Create a some rendering region . LRegion := LFrame.SceneRegion; LRegion.Width := 400; LRegion.Height := 400; . Create a bitmap object . LBitmap := TBitmap.Create; . Render the frame scene . LFrame.RenderScene(LRegion, LBitmap); . Free objects . LBitmap.Free; LFrame.Free; LContainer.Free; LStream.Free; . ⮝ . Example 6. Create a new TABLE . The TABLE extension instance provides a means of storing catalogs and tables of astronomical data in FITS format. Each row of the table consists of a fixed-length sequence of ASCII characters divided into fields that correspond to the columns in the table. Add an HDU of type TFitsTable with the TFitsTableSpec specification to the FITS container. Then get a reference to the TFitsTableData object, and use its properties and methods to iterate through the table’s records and fields to write values. See also the “newtable” demo. uses ..., DeLaFitsCommon, DeLaFitsClasses, DeLaFitsTable; . Create a new empty file and use it to create the FITS container . LStream := TFileStream.Create('new.fits', fmCreate); LContainer := TFitsContainer.Create(LStream); . Create a new table specification with three fields: string, integer, and floating point . LFieldInfo1 := CreateStringFieldInfo( {AFieldNumber:} 1, {AFieldWidth:} 10, {AFieldPosition:} 1, {AFieldName:} 'COLUMN1'); LFieldInfo2 := CreateIntegerFieldInfo( {AFieldNumber:} 2, {AFieldWidth:} 10, {AFieldPosition:} 12, {AFieldName:} 'COLUMN2'); LFieldInfo3 := CreateFixedFieldInfo( {AFieldNumber:} 3, {AFieldWidth:} 10, {AFieldPrecision:} 2, {AFieldPosition:} 23, {AFieldName:} 'COLUMN3'); LSpec := TFitsTableSpec.CreateNewFields( {ARecordSize:} 43, {ARecordCount:} 5, [LFieldInfo1, LFieldInfo2, LFieldInfo3]); . Add a new HDU of type TFitsTable (TABLE extension) to the FITS container. Get a reference to the data object of the selected table . LTable := LContainer.Add(TFitsTable, LSpec) as TFitsTable; LData := LTable.Data; . Get a reference to the table fields . LField1 := LData.Fields[1] as TFitsStringField; LField2 := LData.Fields[2] as TFitsIntegerField; LField3 := LData.Fields[3] as TFitsFloatField; . Write the table records . for LRecordIndex := 0 to LData.RecordCount - 1 do begin LData.OpenRecord(LRecordIndex); LField1.ValueAsString := ...; LField2.ValueAsInteger := ...; LField3.ValueAsDouble := ...; LData.PostRecord; end; . Free objects . LSpec.Free; LContainer.Free; LStream.Free; . ⮝ . Example 7. Read and write the TABLE records . The TABLE extension instance provides a means of storing catalogs and tables of astronomical data in FITS format. Each row of the table consists of a fixed-length sequence of ASCII characters divided into fields that correspond to the columns in the table. To work with table data, set the HDU class to TFitsTable, get a reference to its data object, and iterate over the table’s records and fields to read and write their values. See also the “tablerecords” demo. uses ..., DeLaFitsCommon, DeLaFitsClasses, DeLaFitsTable; . Create the FITS container: open and parse the FITS file . LStream := TFileStream.Create('demo-table.fits', fmOpenReadWrite); LContainer := TFitsContainer.Create(LStream); . Set the HDU class to TFitsTable and get its data object . LIndex := 1; if LContainer.ItemExtensionTypeIs(LIndex, TFitsTable) then begin LContainer.ItemClasses[LIndex] := TFitsTable; LTable := LContainer.Items[LIndex] as TFitsTable; LData := LTable.Data; end; . Get a reference to the table fields . LField1 := LData.FindField('COLUMN1') as TFitsStringField; LField2 := LData.FindField('COLUMN2') as TFitsStringField; LField3 := LData.FindField('COLUMN3') as TFitsIntegerField; LField4 := LData.FindField('COLUMN4') as TFitsFloatField; LField5 := LData.FindField('COLUMN5') as TFitsFloatField; LField6 := LData.FindField('COLUMN6') as TFitsFloatField; . Read the table records . for LRecordIndex := 0 to LData.RecordCount - 1 do begin LData.OpenRecord(LRecordIndex); LValue1 := LField1.ValueAsString; LValue2 := LField2.ValueAsString; LValue3 := LField3.ValueAsInteger; LValue4 := LField4.ValueAsDouble; LValue5 := LField5.ValueAsDouble; LValue6 := LField6.ValueAsDouble; end; . Write the table records . for LRecordIndex := 0 to LData.RecordCount - 1 do begin LData.OpenRecord(LRecordIndex); LField1.ValueAsString := ...; LField2.ValueAsString := ...; LField3.ValueAsInteger := ...; LField4.ValueAsDouble := ...; LField5.ValueAsDouble := ...; LField6.ValueAsDouble := ...; LData.PostRecord; end; . Add a new table record . LData.AddRecord; LField1.ValueAsString := ...; LField2.ValueAsString:= ...; LField3.ValueAsInteger := ...; LField4.ValueAsDouble := ...; LField5.ValueAsDouble := ...; LField6.ValueAsDouble := ...; LData.PostRecord; . Display table records . for LRecordIndex := 0 to LData.RecordCount - 1 do begin LData.OpenRecord(LRecordIndex); LDisplayRecord := ''; for LFieldNumber := 1 to LData.FieldCount do LDisplayRecord := LDisplayRecord + ' ' + LData.Fields[LFieldNumber].DisplayValue; end; . Free objects . LContainer.Free; LStream.Free; . ⮝ . ",
    "url": "https://felleroff.github.io/delafits/pages/getstarted/",
    "relUrl": "/pages/getstarted/"
  },"8": {
    "doc": "Overview",
    "title": "Overview",
    "content": "What is DeLaFits? . DeLaFits is a pure Delphi and Lazarus library for working with data in the FITS format. DeLaFits features: . | parsing a byte stream to an HDU container | creating and deleting an HDU in a container | reading, writing, adding, and deleting HDU header keyword records | reading and writing HDU data array | reading, writing, and rendering physical values (pixels) of an IMAGE extension | reading and writing records and fields of a TABLE extension | . How to use? . Add the DeLaFits directory “source” to your project’s search path. Add references to DeLaFits units. Open the FITS file and create a FITS container from it. Select an HDU from the container and get a pointer to its header and data. Read and write HDU header keyword records. Read and write HDU data byte array. To work with the physical values of an HDU’s data, set its class according to the extension type. uses ..., DeLaFitsCommon, DeLaFitsCard, DeLaFitsClasses, DeLaFitsImage; // Open the FITS file LStream := TFileStream.Create('demo-image.fits', fmOpenRead); // Create a FITS container LContainer := TFitsContainer.Create(LStream); // Get the first HDU from the container, its header and data LItem := LContainer.Items[0]; LHead := LItem.Head; LData := LItem.Data; // Read the HDU header keyword records. Get the date and time // of the observation specified by the keyword \"DATE-OBS\" if LHead.LocateCard('DATE-OBS') then begin LCard := TFitsDateTimeCard.Create; LCard.Card := LHead.Card; LDateTime := LCard.ValueAsDateTime; LCard.Free; end; // Read the HDU data byte array var LBuffer: array of Byte; SetLength(LBuffer, LData.InternalSize); LData.ReadChunk({AInternalOffset:} 0, Length(LBuffer), {var} LBuffer[0]); // Set the HDU class as TFitsImage and read its pixel values if LContainer.ItemExtensionTypeIs({AIndex:} 0, TFitsImage) then begin LContainer.ItemClasses[0] := TFitsImage; LImage := LContainer.Items[0] as TFitsImage; var LPixels: array of Integer; SetLength(LPixels, LImage.Data.ValueCount); LImage.Data.ReadValues({AIndex:} 0, Length(LPixels), {var} TA32c(LPixels)); end; // Free objects LContainer.Free; LStream.Free; . Summary . | Get Started: examples of typical use . | Design: class architecture . | Compilation: conditional compiler directives . | Errors: exceptions and error codes . | . Test environment . DeLaFits is successfully compiled in Delphi 7/2010/12.1 and Lazarus 1.8.4/3.4.0 Unit tests pass successfully on 32- and 64-bit Windows 10 and Linux Mint 19.3/20.3 . ",
    "url": "https://felleroff.github.io/delafits/",
    "relUrl": "/"
  }
}
